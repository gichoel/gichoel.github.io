---
layout: post
title: "예제 코드 실습을 통해 uftrace의 추적 방식 이해해보기"
subtitle: "예제 코드 실습을 통해 uftrace의 추적 방식 이해해보기"
category: profiling
tags: uftrace
---

# 예제 코드 실습을 통해 uftrace의 추적 방식 이해해보기

# 컴파일러의 기능을 활용한 함수 추적 예제

## 1. `finstrument-functions` 기능을 활용한 함수 호출 추적

해당 예제들은 `GCC` 및 `Clang` 컴파일러가 제공하는`finstrument-function` 기능을 활용해 함수 호출 추적 기능을 이해하기 위한
예제로, 프로그램 실행 시 오버헤드를 고려하지 않았기 때문에 프로덕션 환경에서 사용하기에는 무리가 있을 수 있습니다.

### 1-1. finstrument-functions 예제 1

해당 예제는 `__cyg_profile_func_enter()` 함수와 `__cyg_profile_func_exit()` 함수를 사용해 함수의 프롤로그에서
호출한 함수와 호출 당하는 함수의 주소를 출력하고, 함수의 에필로그에서는 마찬가지로 호출했던 함수와 호출 당하는
함수의 주소를 출력하도록 합니다.

- **전체 소스코드**

    ```c
    /* filename : prof.h */
    
    #ifndef __PROF_H__
    #define __PROF_H__
    
    #include <stdio.h>
    
    void __cyg_profile_func_enter(void *, void *) __attribute__((no_instrument_function));
    void __cyg_profile_func_exit(void *, void *) __attribute__((no_instrument_function));
    
    #endif
    ```
 
    ```c
    /* filename : prof.c */
    
    #include "prof.h"
    
    static int call_depth = 0;
    
    void __cyg_profile_func_enter(void *this_func, void *caller_fn) {
            call_depth+=2;
            for(int i=0; i < call_depth; i++) {
                    printf(" ");
            }
    
            printf("[Enter] caller : %p -> func : %p\n", caller_fn, this_func);
    }
    
    void __cyg_profile_func_exit(void *this_func, void *caller_fn) {
            for(int i=0; i < call_depth; i++) {
                    printf(" ");
            }
    
            printf("[Exit] caller : %p <- func : %p\n", caller_fn, this_func);
            call_depth-=2;
    }
    ```
    
    ```c
    /* filename : main.c */
    
    #include "prof.h"
    
    void test3() {
            //printf("test3() func\n");
    }
    
    void test2() {
            //printf("test2() func\n");
            test3();
    }
    
    int test() {
            //printf("test() func\n");
            test2();
    }
    
    int main() {
            //printf("main() func\n");
            test();
    }
    ```
    

- **빌드 명령어**
    
    ```bash
    $ gcc -finstrument-functions -o example01 prof.h prof.c main.c
    ```
    

- **실행 결과**
    
    ```bash
    $ ./example01
    
      [Enter] caller : 0x7f48d8429d90 -> func : 0x56367bcaa2f0
        [Enter] caller : 0x56367bcaa31d -> func : 0x56367bcaa2af
          [Enter] caller : 0x56367bcaa2d7 -> func : 0x56367bcaa26e
            [Enter] caller : 0x56367bcaa296 -> func : 0x56367bcaa237
            [Exit] caller : 0x56367bcaa296 <- func : 0x56367bcaa237
          [Exit] caller : 0x56367bcaa2d7 <- func : 0x56367bcaa26e
        [Exit] caller : 0x56367bcaa31d <- func : 0x56367bcaa2af
      [Exit] caller : 0x7f48d8429d90 <- func : 0x56367bcaa2f0
    ```
    

- **예제 작성 시 참조한 URL**
    - Ref URL 1 : [https://bunhere.tistory.com/279](https://bunhere.tistory.com/279)
    - Ref URL 2 : [https://stackoverflow.com/q/17422712](https://stackoverflow.com/q/17422712)

### 1-2. finstrument-functions 예제 2

앞서 실행했던 예제는 함수의 주소만 출력하기 때문에 함수의 이름을 알 수 없어 어떤 함수가 호출되는지 확인이
어렵다는 단점이 존재합니다.

따라서, 해당 예제에서는 앞서 작성한 예제에 함수의 이름을 같이 출력하는 코드를 추가해보도록 합니다.

 

- **전체 소스코드**
    
    ```c
    /* filename : prof.h */
    
    #ifndef __PROF_H__
    #define __PROF_H__
    
    #include <string.h>
    
    void __cyg_profile_func_enter(void *, void *) __attribute__((no_instrument_function));
    void __cyg_profile_func_exit(void *, void *) __attribute__((no_instrument_function));
    
    #endif
    ```
    
    ```c
    /* filename : prof.c */
    
    #define _GNU_SOURCE
    #include <stdio.h>
    #include <dlfcn.h>
    
    #include "prof.h"
    
    static int call_depth = 0;
    
    void __cyg_profile_func_enter(void *this_func, void *caller_fn) {
            Dl_info callee_info;
            Dl_info caller_info;
    
            call_depth+=2;
            for(int i=0; i < call_depth; i++) {
                    printf(" ");
            }
    
            if ( dladdr(this_func, &callee_info) && dladdr(caller_fn, &caller_info) ) {
                    printf("[Enter] (%s) : %p -> (%s) : %p\n", caller_info.dli_sname, caller_fn, callee_info.dli_sname, this_func);
            } else {
                    printf("[Enter] caller : %p -> func : %p\n", caller_fn, this_func);
            }
    }
    
    void __cyg_profile_func_exit(void *this_func, void *caller_fn) {
            Dl_info callee_info;
            Dl_info caller_info;
    
            for(int i=0; i < call_depth; i++) {
                    printf(" ");
            }
    
            if ( dladdr(this_func, &callee_info) && dladdr(caller_fn, &caller_info) ) {
                    printf("[Exit] (%s) : %p <- (%s) : %p\n", caller_info.dli_sname, caller_fn, callee_info.dli_sname, this_func);
            } else {
                    printf("[Exit] caller : %p <- func : %p\n", caller_fn, this_func);
            }
    
            call_depth-=2;
    }
    
    ```
    
    ```c
    /* filename : main.c */
    
    #include "prof.h"
    
    void test3() {
            //printf("test3() func\n");
    }
    
    void test2() {
            //printf("test2() func\n");
            test3();
    }
    
    int test() {
            //printf("test() func\n");
            test2();
    }
    
    int main() {
            //printf("main() func\n");
            test();
    }
    ```
    
- **빌드 명령어**
    - 함수 이름으로 변환하는 기능이 동작하기 위해서는 **`rdynamic`** 옵션이 필수로 있어야 합니다.
    
    ```bash
    $ gcc -finstrument-functions -rdynamic -o example02 prof.h prof.c main.c -ldl
    ```
    
- **실행 결과**
    
    ```bash
    $ ./example02
    
      [Enter] ((null)) : 0x7fc026229d90 -> (main) : 0x556ff065c42a
        [Enter] (main) : 0x556ff065c457 -> (test) : 0x556ff065c3e9
          [Enter] (test) : 0x556ff065c411 -> (test2) : 0x556ff065c3a8
            [Enter] (test2) : 0x556ff065c3d0 -> (test3) : 0x556ff065c371
            [Exit] (test2) : 0x556ff065c3d0 <- (test3) : 0x556ff065c371
          [Exit] (test) : 0x556ff065c411 <- (test2) : 0x556ff065c3a8
        [Exit] (main) : 0x556ff065c457 <- (test) : 0x556ff065c3e9
      [Exit] ((null)) : 0x7fc026229d90 <- (main) : 0x556ff065c42a
    
    ```
    
- **예제 작성 시 참조한 URL**
    - Ref URL 1 : [https://stackoverflow.com/a/19761428](https://stackoverflow.com/a/19761428)
    - Ref URL 2 : [https://stackoverflow.com/q/74443851](https://stackoverflow.com/q/74443851)
    - Ref URL 3 : [https://wariua.github.io/man-pages-ko/dladdr(3)](https://wariua.github.io/man-pages-ko/dladdr%283%29/)
    - Ref URL 4 : [https://stackoverflow.com/q/11731229](https://stackoverflow.com/q/11731229)

## 2. `mcount()` 함수를 활용한 함수 호출 추적

앞서 진행했던 `finstrument-functions` 예제는 추적에 사용되는 함수를 C언어로 구현해야 하지만, 이번 예제에서 사용할 `mcount()` 함수는 어셈블리어로 구현하게 되어 성능상의 이점을 가질 수 있습니다.

### 2-1. mcount() 예제 1
이번 mcount() 함수를 활용한 함수 호출 추적 예제는 1-1번 예제와 동일하게 함수의 주소만 출력하도록 하였으며,
이번에는 호출되는 함수 내부에서 어떤 함수가 호출되는지 printf()로 함수 이름을 출력함으로써 동작 과정을 확인할 수 있도록 하였습니다.

- **전체 소스코드**
    
    ```nasm
    /* filename : mcount.S */
    .text
    .global mcount
    
    mcount:
    	sub $48, %rsp
    
    	/* save argument registers */
    	movq %rdi, 40(%rsp)
    	movq %rsi, 32(%rsp)
    	movq %rdx, 24(%rsp)
    	movq %rcx, 16(%rsp)
    	movq %r8, 8(%rsp)
    	movq %r9, 0(%rsp)
    
    	/* child addr == return address of mcount() func stack */
    	movq 48(%rsp), %rdi
    
    	/* parent location == return address of callee func stack */
    	movq 8(%rbp), %rsi
    
    	push %rax
    
    	call print_instrument_func_info
    
    	pop %rax
    
    	movq 0(%rsp), %r9
    	movq 8(%rsp), %r8
    	movq 16(%rsp), %rcx
    	movq 24(%rsp), %rdx
    	movq 32(%rsp), %rsi
    	movq 40(%rsp), %rdi
    
    	add $48, %rsp
    
    	retq
    ```
    
    ```c
    /* filename : prof.h */
    
    #ifndef __PROF_H__
    #define __PROF_H__
    
    void print_instrument_func_info(unsigned long ip, unsigned long parent_ip) __attribute__((no_instrument_function));
    
    #endif
    ```
    
    ```c
    /* filename : prof.c */
    
    #include <stdio.h>
    #include "prof.h"
    
    void print_instrument_func_info(unsigned long ip, unsigned long parent_ip) {
    	printf("[mcount] caller : %p -> func : %p, \n", (void *)parent_ip, (void *)ip);
    }
    ```
    
    ```c
    /* filename : main.c */
    
    #include <stdio.h>
    #include "prof.h"
    
    int foo()
    {
            printf(" + foo() called\n\n");
            return 1;
    }
    
    int bar()
    {
            printf(" + bar() called\n\n");
            return foo();
    }
    
    int recursive(int a)
    {
            printf(" + recursive(%d) called\n\n", a);
            if(!a)
                    return 0;
            recursive(a-1);
    }
    
    int main()
    {
            printf(" + main() called\n\n");
            bar();
            recursive(4);
    }
    ```
    

- **빌드 명령어**
    
    ```bash
    $ gcc -pg -rdynamic -o mcount_exam1 mcount.S prof.h prof.c main.c
    ```
    

- **실행 결과**
    
    ```bash
    $ ./mcount_exam1 
    
    [mcount] caller : 0x73d70f229d90 -> func : 0x5d6d65a72307
     + main() called
    
    [mcount] caller : 0x5d6d65a72320 -> func : 0x5d6d65a72294
     + bar() called
    
    [mcount] caller : 0x5d6d65a722ad -> func : 0x5d6d65a72270
     + foo() called
    
    [mcount] caller : 0x5d6d65a7232a -> func : 0x5d6d65a722c1
     + recursive(4) called
    
    [mcount] caller : 0x5d6d65a722f7 -> func : 0x5d6d65a722c1
     + recursive(3) called
    
    [mcount] caller : 0x5d6d65a722f7 -> func : 0x5d6d65a722c1
     + recursive(2) called
    
    [mcount] caller : 0x5d6d65a722f7 -> func : 0x5d6d65a722c1
     + recursive(1) called
    
    [mcount] caller : 0x5d6d65a722f7 -> func : 0x5d6d65a722c1
     + recursive(0) called
    
    ```
    

- **예제 작성 시 참조한 URL**
    - Ref URL 1 : [https://tirkarp.medium.com/understanding-x86-assembly-5d7d637efb5](https://tirkarp.medium.com/understanding-x86-assembly-5d7d637efb5)
    - Ref URL 2 : [https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax](https://en.wikibooks.org/wiki/X86_Assembly/GNU_assembly_syntax)
    - Ref URL 3 : [https://github.com/namhyung/uftrace/blob/master/arch/x86_64/mcount.S](https://github.com/namhyung/uftrace/blob/master/arch/x86_64/mcount.S)
    - Ref URL 4 : [https://github.com/YWHyuk/small_tracer/blob/master/mcount.S](https://github.com/YWHyuk/small_tracer/blob/master/mcount.S)
    - Ref URL 5 : [https://www.bhral.com/post/linux-kernel-ftrace-간단한-원리](https://www.bhral.com/post/linux-kernel-ftrace-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%9B%90%EB%A6%AC)

### 2-2. mcount() 예제 2 

- **전체 소스코드**
    
    ```nasm
    /* filename : mcount.S */
    .text
    .global mcount
    
    mcount:
    	sub $48, %rsp
    
    	/* save argument registers */
    	movq %rdi, 40(%rsp)
    	movq %rsi, 32(%rsp)
    	movq %rdx, 24(%rsp)
    	movq %rcx, 16(%rsp)
    	movq %r8, 8(%rsp)
    	movq %r9, 0(%rsp)
    
    	/* child addr == return address of mcount() func stack */
    	movq 48(%rsp), %rdi
    
    	/* parent location == return address of callee func stack */
    	movq 8(%rbp), %rsi
    
    	push %rax
    
    	call print_instrument_func_info
    
    	pop %rax
    
    	movq 0(%rsp), %r9
    	movq 8(%rsp), %r8
    	movq 16(%rsp), %rcx
    	movq 24(%rsp), %rdx
    	movq 32(%rsp), %rsi
    	movq 40(%rsp), %rdi
    
    	add $48, %rsp
    
    	retq
    ```
    
    ```c
    /* filename : prof.h */
    
    #ifndef __PROF_H__
    #define __PROF_H__
    
    void print_instrument_func_info(unsigned long ip, unsigned long parent_ip) __attribute__((no_instrument_function));
    
    #endif
    ```
    
    ```c
    /* filename : prof.c */
    
    #define _GNU_SOURCE
    #include <stdio.h>
    #include <dlfcn.h>
    
    #include "prof.h"
    
    void print_instrument_func_info(unsigned long ip, unsigned long parent_ip) {
            Dl_info callee_info;
            Dl_info caller_info;
    
            if ( dladdr((void *)ip, &callee_info) && dladdr((void *)parent_ip, &caller_info) ) {
                    printf("(%s) : %p -> (%s) : %p\n", caller_info.dli_sname, (void *)parent_ip, callee_info.dli_sname, (void *)ip);
            } else {
                    printf("caller : %p -> func : %p, \n", (void *)parent_ip, (void *)ip);
            }
    }
    ```
    
    ```c
    /* filename : main.c */
    
    #include "prof.h"
    
    int foo()
    {
    	return 1;
    }
    
    int bar()
    {
    	return foo();
    }
    
    int recursive(int a)
    {
    	if(!a) {
    		return 0; 
    	}
    
    	recursive(a-1);
    }
    
    int main()
    {
    	bar();
    	recursive(3);
    }
    
    ```
    

- **빌드 명령어**
    
    ```bash
    $ gcc -pg -rdynamic -o mcount_exam2 mcount.S prof.h prof.c main.c
    ```
    

- **실행 결과**
    
    ```bash
    $ ./mcount_exam2
    
    ((null)) : 0x7f73cf829d90 -> (main) : 0x5639a7a9434d
    (main) : 0x5639a7a94357 -> (bar) : 0x5639a7a94302
    (bar) : 0x5639a7a9430c -> (foo) : 0x5639a7a942ed
    (main) : 0x5639a7a94361 -> (recursive) : 0x5639a7a94320
    (recursive) : 0x5639a7a9433d -> (recursive) : 0x5639a7a94320
    (recursive) : 0x5639a7a9433d -> (recursive) : 0x5639a7a94320
    (recursive) : 0x5639a7a9433d -> (recursive) : 0x5639a7a94320
    ```
    

- **예제 작성 시 참조한 URL**
    - Ref URL 1 : [https://tirkarp.medium.com/understanding-x86-assembly-5d7d637efb5](https://tirkarp.medium.com/understanding-x86-assembly-5d7d637efb5)
    - Ref URL 2 : [https://github.com/namhyung/uftrace/blob/master/arch/x86_64/mcount.S](https://github.com/namhyung/uftrace/blob/master/arch/x86_64/mcount.S)
    - Ref URL 3 : [https://github.com/YWHyuk/small_tracer/blob/master/mcount.S](https://github.com/YWHyuk/small_tracer/blob/master/mcount.S)
    - Ref URL 4 : [https://www.bhral.com/post/linux-kernel-ftrace-간단한-원리](https://www.bhral.com/post/linux-kernel-ftrace-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%9B%90%EB%A6%AC)
    - Ref URL 5 : [https://stackoverflow.com/a/19761428](https://stackoverflow.com/a/19761428)
    - Ref URL 6 : [https://stackoverflow.com/q/74443851](https://stackoverflow.com/q/74443851)
    - Ref URL 7 : [https://wariua.github.io/man-pages-ko/dladdr(3)](https://wariua.github.io/man-pages-ko/dladdr%283%29/)
    - Ref URL 8 : [https://stackoverflow.com/q/11731229](https://stackoverflow.com/q/11731229)

## 3. PLT Hooking 기법 예제

### 3-1. 해당 예제를 이해하기 위해 필요한 배경 지식

- **C/C++ 계열 프로그램 코드 빌드 과정**
    ![Untitled](/assets/posts/uftrace/2024-11-24/func_tracing_exam/Untitled.png)

    - **컴파일러**
        - 여기서는 조금 구조를 단순화 하기 위해 **컴파일러가 아래 3가지 과정을 통합하였다고 가정**하며, 해당 과정은 우리가 구현한 소스코드를 CPU가 이해할 수 있는 기계어로 변환하는 과정을 진행한다.
            1. **Preprocessor 단계**
                - Preprocessor에 의해 `#if`와 같은 전처리문을 처리하는 과정을 수행하고, 전처리문에 의해 남겨져야 할 코드만 남은 `.c` 또는 `.cpp` 파일을 결과물로 내보낸다.
            2. **Complier 단계**
                - Preprocessor가 내보낸 결과물을 Compiler가 받아 어셈블리어로 변환하는 과정을 수행하고, `.s` 파일을 결과물로 내보낸다.
            3. **Assembler 단계**
                - Compiler가 내보낸 결과물을 Assembler가 받아 기계어로 구성된 목적 파일(오브젝트 파일)로 변환하는 과정을 수행하고, `.o` 파일을 결과물로 내보낸다.
        
    - **링커**
        - 소스 코드에서 외부 라이브러리 함수를 호출하도록 작성 되었다면, Assembler에 의해 생성된 목적 파일에는 외부 라이브러리 함수를 호출한다 까지만 존재하는 상태이다.
        - 링커는 우리가 작성한 소스 코드의 목적 파일에 외부 라이브러리 함수의 목적 파일을 가져와 연결해주는 역할을 하며, 이 때 **라이브러리를 연결하는 방식에 따라 `Static Link`와 `Dynamic Link` 방식으로 나뉘게** 된다.
            - `Static Link` 방식과 `Dynamic Link` 방식에 따라 링커가 목적 파일을 내부에 포함할지 아니면 외부에서 가져다 사용할 수 있도록 할지 프로그램을 구성하는 방식이 달라진다.

- **Static Link와 Dynamic Link 방식**
    - **Static Link**
        - Static Link 방식은 소스코드를 빌드할 때 사용한 라이브러리 함수 코드를 프로그램 내부에 포함하는 방식으로, 해당 방법의 장점과 단점은 아래와 같음
            - **Static Link 방식의 장점**
                - `.so` 와 같은 동적 라이브러리 파일을 프로그램 배포 시 같이 배포할 필요가 없음 (시스템에 기본적으로 이미 존재하는 동적 라이브러리 파일은 예외)
                - 프로그램 외부에서 주소를 찾아오는 과정을 거칠 필요가 없기 때문에 Dynamic Link 방식에 비해 프로그램 실행 속도가 빠름
                
            - **Static Link 방식의 단점**
                - 실행 파일 내부에 사용한 라이브러리 함수만 불러오는 것이 아닌 해당 함수가 포함된 라이브러리의 전체 코드를 포함하기 때문에 디스크에 저장되는 실행 파일의 크기가 커짐
                - 디스크에 저장된 실행파일은 로더에 의해 몇 가지 과정을 거쳐 메모리에 올라가는데 실행 파일의 크기가 크기 때문에 프로그램이 메모리에 올라갔을 때 사용하는 메모리 공간도 커짐
                - 소스코드를 빌드할 때 매번 라이브러리 코드도 같이 빌드를 해야하기 때문에 빌드 시간이 오래 걸림
                
    - **Dynamic Link**
        - Dynamic Link 방식은 소스코드를 빌드할 때 사용한 라이브러리 함수 코드를 프로그램 외부에서 가져와 사용할 수 있도록 하는 방식으로, 해당 방법의 장점과 단점은 아래와 같음
            - **Dynamic Link 방식의 장점**
                - 실행 파일 내부에 사용한 라이브러리의 전체 코드를 포함할 필요가 없기 때문에 디스크에 저장되는 실행 파일의 크기가 작음
                - 디스크에 저장된 실행파일의 크기가 작기 때문에 프로그램이 메모리에 올라갔을 때 적은 공간의 메모리를 사용
                - 사용한 라이브러리 코드를 매번 빌드 할 필요가 없기 때문에 빌드 시간이 단축됨
                
            - **Dynamic Link 방식의 단점**
                - 배포하는 시스템에 동적 라이브러리 파일인 .so 파일이 존재하지 않는다면 프로그램 배포 시 같이 배포를 수행해야 함
                - 프로그램 실행 시 라이브러리 함수들이 처음 호출 될 때 라이브러리의 함수 주소를 구해야 하기 때문에 Static Link 방식에 비해 속도가 느림 (단, 해당 과정은 라이브러리 함수들이 처음 호출 될 때 각각 한번만 수행되기 때문에 큰 영향을 미치지 않음)

- **PLT와 GOT란?**
    - 우리는 프로그램을 개발할 때 필요한 모든 함수들을 구현할 수 없기도 하고, 이러한 함수들은 이미 누군가가 만들어서 제공하고 있기 때문에 외부 라이브러리의 함수를 가져다 사용한다.
    - `Static Link`방식으로 빌드된 프로그램 내부에 라이브러리 함수가 구현된 코드를 포함되기 때문에 링킹 시점에 주소를 구할 수 있지만, `Dynamic Link` 방식으로 빌드된 프로그램은 라이브러리 함수가 구현 코드가 프로그램의 외부에 존재해 프로그램 실행 시 별도로 찾아가는 과정이 필요한데 이 때 사용되는 개념이 `PLT`와 `GOT`이다.
    
    - **PLT**
        - 프로그램 소스코드 빌드 과정 중 링킹 시점에 주소를 구할 수 없는 외부 라이브러리 함수를 호출할 수 있도록 제공하는 용도
        - 우리가 작성한 코드가 외부 라이브러리를 사용하도록 되어있고, 링킹 시점에 주소를 구할 수 없는 경우 `.PLT` 섹션에 존재하는 해당 라이브러리 대체 함수 코드를 호출하도록 연결해준다.
        - 이후 해당 라이브러리의 대체 함수는 실제 라이브러리 함수를 찾아 호출될 수 있도록 수행하는 작업을 진행하며, 이 부분만 봤을 때는 PLT만 있으면 되는데 왜 GOT가 필요한 것인지 궁금할 수 있다.
            - 해당 내용은 GOT를 설명하며 왜 GOT가 필요한지 소개할 예정이니 아래에서 GOT 설명에서 참고하면 된다.
        - `.PLT` 섹션은 **코드 영역이기 때문에 프로그램 실행 중 쓰기가 불가능 한 읽기만 가능한 영역**으로, 프로그램에서 `.text` 섹션과 같은 코드 영역은 보안상의 이유로 읽기만 가능하도록 설정된다.
            - 만약, 코드 영역에 쓰기가 가능하다면 공격자는 프로그램이 실행되는 도중에 원하는 코드를 수정할 수 있도록 코드 영역의 코드를 바꿔버리기만 하면 되기 때문이다.
        
    - **GOT**
        - `.PLT` 섹션에 존재하는 해당 라이브러리의 대체 함수 코드가 구해온 실제 라이브러리의 함수 주소를 구해온 뒤 호출이 되면 동작에는 문제가 없다.
        - 하지만, 실제 라이브러리의 함수 주소를 구하는 과정은 생각보다 많은 추가 시간을 소모하게 되는데, 만약 `.PLT`만 존재해 매번 실제 라이브러리의 함수 주소를 구하는 과정이 매번 수행되어야 한다면 외부 라이브러리 함수를 호출하면 호출할수록 프로그램은 더욱더 느려지게 된다.
        - 그렇기 때문에 프로그램 내부에 `.PLT` 섹션의 라이브러리 대체 함수가 구해온 주소를 저장할 영역이 필요했고, 그러한 역할을 하는 섹션이 `.GOT` 섹션이다.
        - `.GOT` 섹션은 위에서 말한 `.PLT` 섹션과는 다르게 데이터 영역이기 때문에 프로그램 실행 중 읽고 쓰기가 가능한 영역이다.

- **Hooking과 Trampoline 용어 정의**
    - 영문 사전에 정의 된 Hook의 정의는 명사로는 갈고리, 바늘 동사로는 갈고리로 걸다의 의미를 가지고 있다.
    - 사전에 정의된 것 처럼 소프트웨어 공학에서 Hooking은 함수 호출, 이벤트 등을 가로채 원하는 행위를 수행하는 것을 의미한다.
    - Trampoline은 Hooking을 수행한 함수 호출, 이벤트 등을 원래 가야할 목적지로 전달해 주는 것 까지의 Hooking 과정을 말하지만, 주로 Hooking을 진행하는 목적은 원래 수행하는 행위에서 추가 행위를 수행하기 위한 것이 대부분이기 때문에 Trampoline의 개념이 Hooking의 개념으로 통용되기도 한다.
    
- **PLT Hooking이란?**
    - 위에서 설명한 PLT 또는 GOT를 덮어써서 외부 라이브러리 함수 호출 시 원하는 동작을 수행할 수 있는 후킹 기법
    - `mcount()` 함수는 빌드 시 `-pg` 옵션을 사용한 프로그램의 함수들에만 삽입이 되는데, `strcpy(), printf()`와 같은 외부 함수들은 `-pg` 옵션으로 빌드 된 것이 아니기 때문에 추적이 불가능하고 그러한 이유로 uftrace에서는 `PLT Hook`을 사용해 외부 라이브러리 함수 호출을 추적한다.

## 2-2. PLT Hooking으로 호출되는 라이브러리 함수를 변경하는 예제

- **사전 준비**
    
    ```bash
    # Ubuntu일 경우 아래 명령 먼저 실행
    $ sudo apt-get install python3.10-venv
    
    # 원하는 디렉토리로 이동 한 뒤 아래 명령 순차 실행
    $ python3 -m venv .venv
    $ source .venv/bin/activate
    
    $ pip3 install pwn
    ```
    
- **타겟 프로그램 소스코드**
    
    ```c
    /* filename : plthook_exam.c */
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    void test3() {
    	printf("test3() func called\n");
    }
    
    void test2() {
    	printf("test2() func called\n");
    }
    
    int main() {
    	char a[50];
    	memset(a, 0, sizeof(a));
    
    	printf("program start\n");
    	printf("\n");
    
    	printf("current pid : %d\n", getpid());
    	printf("\n");
    
    	printf("sprintf() called here\n");
    	sprintf(a, "str : %s, int : %d", "test_str", 30);
    	printf("%s", a);
    
    	printf("\n");
    	test3();
    
    	printf("\n");
    	printf("program end\n");
    
    	return 0;
    }
    ```
    

- **타겟 프로그램 빌드 명령어**
    - 아래 PLT Hook 예제 코드가 동작하기 위해서는 **ELF 실행 파일의 RELRO 보호 옵션**이 꺼져 있어야 한다.
    
    ```bash
    $ gcc -no-pie -fno-PIE -o plthook_exam plthook_exam.c
    ```
    

- **PLT Hook 예제 소스코드**
    
    ```python
    # filename : plthook.py
    from pwn import *
    
    e = ELF('./plthook_exam')
    
    e.pack(e.got['sprintf'], e.functions['test2'].address)
    
    e.save('./plthook_exam_modified')
    ```
    

- **PLT Hook 예제 실행 방법**
    
    ```bash
    $ gcc -no-pie -fno-PIE -o plthook_exam plthook_exam.c
    $ python3 plthook.py
    
    # 원본 파일 실행 및 결과 확인
    $ ./plthook_exam
    
    # PLT Hook이 적용된 파일 실행 결과
    $ ./plthook_exam_modified
    ```
    

- **실행 결과**
    
    ```bash
    $ ./plthook_exam
    
    program start
    
    current pid : 61408
    
    sprintf() called here
    str : test_str, int : 30
    
    test3() func called
    
    program end
    
    #---------------------------------
    
    $ ./plthook_exam_modified
    
    program start
    
    current pid : 61409
    
    sprintf() called here
    test2() func called
    
    test3() func called
    
    program end
    ```
    

- **예제 작성 시 참조한 URL**
    - Ref URL 1 : [https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md#patching-elf-files](https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md#patching-elf-files)
    - Ref URL 2 : [https://github.com/kubo/plthook](https://github.com/kubo/plthook)
    - Ref URL 3 : [https://bbolmin.tistory.com/75](https://bbolmin.tistory.com/75)
    - Ref URL 4 : [https://velog.io/@wonder_land/Pwnable-10.-Background-RELRO](https://velog.io/@wonder_land/Pwnable-10.-Background-RELRO)

## 4. Dynamic Tracing 기법 예제

### 4-1. 예제를 이해하기 위해 필요한 배경 지식

- **가상 메모리 맵이란?**

- **Linux가 가상 메모리와 물리 메모리를 매핑하는 방법**

- **Linux의 프로세스 가상 메모리 레이아웃 분석**

- **/proc/<pid>/maps 파일이란?**

- **프로세스의 maps 파일 분석하기**

### 4-2. `/proc/<pid>/maps` 파일 수작업으로 분석해보기

uftrace의 Dynamic Tracing 기법을 이해하기 위한 예제를 설명하기 위한 작업으로 `objdump -d`와 `readelf -SW` 명령을
사용해 `.text` 영역의 오프셋을 찾는다고 하니 이해가 안될 수 있는데 코드로 구현하기 전
`/proc/[타겟 pid]/maps` 파일을 수작업으로 분석해보기 위한 예제입니다.

- **예제 코드**
    
    ```c
    /* filename : test.c */
    
    #include <stdio.h>
    #include <unistd.h>
    
    void callme() {
    	printf("callme() func called\n");
    }
    
    int main() {
    	printf("my pid : %d\n", getpid());
    	printf("main() func's addr : %p\n", (void *)main);
    
    	callme();
    
    	while(1);
    }
    ```
    

- **타겟 프로그램 빌드 명령어**
    
    ```bash
    $ gcc -o test_prog test.c
    ```
    

- **해당 프로세스의 maps 파일 확인하기**
    
    ```bash
    # 첫 번째 Termianl 화면
    $ ./test_prog
    
    my pid : 4231
    main() func's addr : 0x556021d32169
    
    # 두 번째 Terminal 화면(위에서 확인한 my pid가 중간의 <pid>에 들어감)
    $ cat /proc/<pid>/maps
    
    556021d31000-556021d32000 r--p 00000000 08:03 2102898                    /home/test/workdir/test_prog
    556021d32000-556021d33000 r-xp 00001000 08:03 2102898                    /home/test/workdir/test_prog
    556021d33000-556021d34000 r--p 00002000 08:03 2102898                    /home/test/workdir/test_prog
    556021d34000-556021d35000 r--p 00002000 08:03 2102898                    /home/test/workdir/test_prog
    556021d35000-556021d36000 rw-p 00003000 08:03 2102898                    /home/test/workdir/test_prog
    556022ecb000-556022eec000 rw-p 00000000 00:00 0                          [heap]
    7f4e4cc00000-7f4e4cc28000 r--p 00000000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4cc28000-7f4e4cdbd000 r-xp 00028000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4cdbd000-7f4e4ce15000 r--p 001bd000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4ce15000-7f4e4ce19000 r--p 00214000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4ce19000-7f4e4ce1b000 rw-p 00218000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4ce1b000-7f4e4ce28000 rw-p 00000000 00:00 0 
    7f4e4ce77000-7f4e4ce7a000 rw-p 00000000 00:00 0 
    7f4e4ce8c000-7f4e4ce8e000 rw-p 00000000 00:00 0 
    7f4e4ce8e000-7f4e4ce90000 r--p 00000000 08:03 1061693                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    7f4e4ce90000-7f4e4ceba000 r-xp 00002000 08:03 1061693                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    7f4e4ceba000-7f4e4cec5000 r--p 0002c000 08:03 1061693                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    7f4e4cec6000-7f4e4cec8000 r--p 00037000 08:03 1061693                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    7f4e4cec8000-7f4e4ceca000 rw-p 00039000 08:03 1061693                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    7ffe9a7e3000-7ffe9a804000 rw-p 00000000 00:00 0                          [stack]
    7ffe9a9ef000-7ffe9a9f3000 r--p 00000000 00:00 0                          [vvar]
    7ffe9a9f3000-7ffe9a9f5000 r-xp 00000000 00:00 0                          [vdso]
    ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
    
    ```
    

- **`readelf -SW` 명령을 사용해 `.text` 섹션의 오프셋 찾기**
    - `readelf -SW` 명령을 실행한 뒤 `.text` 섹션의 정보를 확인한 결과 해당 프로그램의 `.text` 섹션 오프셋은 `0x1080`인 것을 확인할 수 있음
    
    ```bash
    $ readelf -SW test_prog
    
    There are 31 section headers, starting at offset 0x36c8:
    
    Section Headers:
      [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
      [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
      [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1
      [ 2] .note.gnu.property NOTE            0000000000000338 000338 000030 00   A  0   0  8
      [ 3] .note.gnu.build-id NOTE            0000000000000368 000368 000024 00   A  0   0  4
      [ 4] .note.ABI-tag     NOTE            000000000000038c 00038c 000020 00   A  0   0  4
      [ 5] .gnu.hash         GNU_HASH        00000000000003b0 0003b0 000024 00   A  6   0  8
      [ 6] .dynsym           DYNSYM          00000000000003d8 0003d8 0000c0 18   A  7   1  8
      [ 7] .dynstr           STRTAB          0000000000000498 000498 000096 00   A  0   0  1
      [ 8] .gnu.version      VERSYM          000000000000052e 00052e 000010 02   A  6   0  2
      [ 9] .gnu.version_r    VERNEED         0000000000000540 000540 000030 00   A  7   1  8
      [10] .rela.dyn         RELA            0000000000000570 000570 0000c0 18   A  6   0  8
      [11] .rela.plt         RELA            0000000000000630 000630 000030 18  AI  6  24  8
      [12] .init             PROGBITS        0000000000001000 001000 00001b 00  AX  0   0  4
      [13] .plt              PROGBITS        0000000000001020 001020 000030 10  AX  0   0 16
      [14] .plt.got          PROGBITS        0000000000001050 001050 000010 10  AX  0   0 16
      [15] .plt.sec          PROGBITS        0000000000001060 001060 000020 10  AX  0   0 16
      **[16] .text             PROGBITS        0000000000001080 001080 00012c 00  AX  0   0 16**
      [17] .fini             PROGBITS        00000000000011ac 0011ac 00000d 00  AX  0   0  4
      [18] .rodata           PROGBITS        0000000000002000 002000 00002a 00   A  0   0  4
      [19] .eh_frame_hdr     PROGBITS        000000000000202c 00202c 000034 00   A  0   0  4
      [20] .eh_frame         PROGBITS        0000000000002060 002060 0000a8 00   A  0   0  8
      [21] .init_array       INIT_ARRAY      0000000000003db0 002db0 000008 08  WA  0   0  8
      [22] .fini_array       FINI_ARRAY      0000000000003db8 002db8 000008 08  WA  0   0  8
      [23] .dynamic          DYNAMIC         0000000000003dc0 002dc0 0001f0 10  WA  7   0  8
      [24] .got              PROGBITS        0000000000003fb0 002fb0 000050 08  WA  0   0  8
      [25] .data             PROGBITS        0000000000004000 003000 000010 00  WA  0   0  8
      [26] .bss              NOBITS          0000000000004010 003010 000008 00  WA  0   0  1
      [27] .comment          PROGBITS        0000000000000000 003010 00002b 01  MS  0   0  1
      [28] .symtab           SYMTAB          0000000000000000 003040 000378 18     29  18  8
      [29] .strtab           STRTAB          0000000000000000 0033b8 0001f0 00      0   0  1
      [30] .shstrtab         STRTAB          0000000000000000 0035a8 00011a 00      0   0  1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
      L (link order), O (extra OS processing required), G (group), T (TLS),
      C (compressed), x (unknown), o (OS specific), E (exclude),
      D (mbind), l (large), p (processor specific)
    
    ```
    

- **위에서 찾은 `.text` 섹션의 오프셋 값을 `objdump -d` 명령 결과와 비교해보기**
    - 위에서 확인한 것 처럼 `Disassembly of section .text:` 로 시작하는 문자열 바로 아래 나오는 함수인 `_start()`의 오프셋 값은 `0x1080`인 것을 확인할 수 있음
    - 추가적으로, 위에서는 설명하지 않았지만 실행파일의 디스어셈블 결과만을 출력해주는 `objdump -d` 명령의 첫 Section인 `.init`은 `0x1000`으로 시작하는데 위 `readelf -SW` 결과를 확인하면 알 수 있지만 `.init` 섹션의 오프셋 값도 `0x1000`인 것을 확인할 수 있음
    
    ```bash
    $ objdump -d test_prog
    
    test:     file format elf64-x86-64
    
    Disassembly of section .init:
    
    0000000000001000 <_init>:
        1000:	f3 0f 1e fa          	endbr64 
        1004:	48 83 ec 08          	sub    $0x8,%rsp
        1008:	48 8b 05 d9 2f 00 00 	mov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>
        100f:	48 85 c0             	test   %rax,%rax
        1012:	74 02                	je     1016 <_init+0x16>
        1014:	ff d0                	call   *%rax
        1016:	48 83 c4 08          	add    $0x8,%rsp
        101a:	c3                   	ret    
    
    Disassembly of section .plt:
    
    0000000000001020 <.plt>:
        1020:	ff 35 92 2f 00 00    	push   0x2f92(%rip)        # 3fb8 <_GLOBAL_OFFSET_TABLE_+0x8>
        1026:	f2 ff 25 93 2f 00 00 	bnd jmp *0x2f93(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x10>
        102d:	0f 1f 00             	nopl   (%rax)
        1030:	f3 0f 1e fa          	endbr64 
        1034:	68 00 00 00 00       	push   $0x0
        1039:	f2 e9 e1 ff ff ff    	bnd jmp 1020 <_init+0x20>
    
    ......
    
    **Disassembly of section .text:**
    
    **0000000000001080 <_start>:**
        1080:	f3 0f 1e fa          	endbr64 
        1084:	31 ed                	xor    %ebp,%ebp
        1086:	49 89 d1             	mov    %rdx,%r9
        1089:	5e                   	pop    %rsi
        108a:	48 89 e2             	mov    %rsp,%rdx
        108d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
        1091:	50                   	push   %rax
        1092:	54                   	push   %rsp
        1093:	45 31 c0             	xor    %r8d,%r8d
        1096:	31 c9                	xor    %ecx,%ecx
        1098:	48 8d 3d ca 00 00 00 	lea    0xca(%rip),%rdi        # 1169 <main>
        109f:	ff 15 33 2f 00 00    	call   *0x2f33(%rip)        # 3fd8 <__libc_start_main@GLIBC_2.34>
        10a5:	f4                   	hlt    
        10a6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
        10ad:	00 00 00 
    
    ......
    
    0000000000001169 <main>:
        1169:	f3 0f 1e fa          	endbr64 
        116d:	55                   	push   %rbp
        116e:	48 89 e5             	mov    %rsp,%rbp
        1171:	e8 ea fe ff ff       	call   1060 <getpid@plt>
        1176:	89 c6                	mov    %eax,%esi
        1178:	48 8d 05 85 0e 00 00 	lea    0xe85(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
        117f:	48 89 c7             	mov    %rax,%rdi
        1182:	b8 00 00 00 00       	mov    $0x0,%eax
        1187:	e8 e4 fe ff ff       	call   1070 <printf@plt>
        118c:	48 8d 05 d6 ff ff ff 	lea    -0x2a(%rip),%rax        # 1169 <main>
        1193:	48 89 c6             	mov    %rax,%rsi
        1196:	48 8d 05 74 0e 00 00 	lea    0xe74(%rip),%rax        # 2011 <_IO_stdin_used+0x11>
        119d:	48 89 c7             	mov    %rax,%rdi
        11a0:	b8 00 00 00 00       	mov    $0x0,%eax
        11a5:	e8 c6 fe ff ff       	call   1070 <printf@plt>
        11aa:	eb fe                	jmp    11aa <main+0x41>
    
    Disassembly of section .fini:
    
    00000000000011ac <_fini>:
        11ac:	f3 0f 1e fa          	endbr64 
        11b0:	48 83 ec 08          	sub    $0x8,%rsp
        11b4:	48 83 c4 08          	add    $0x8,%rsp
        11b8:	c3                   	ret    
    
    ```
    

- **해당 프로세스의 maps 파일의 결과를 토대로 .text 영역의 실제 메모리 위치 검증해보기**
    - 해당 프로그램은 아래 결과에서 `0x556021d31000` 가상 메모리 주소에서 시작하는 것을 확인할 수 있고, 위에서 구한 `.text` 섹션 오프셋 값인 `0x1080`을 더하게 되면 프로세스 주소 공간에서 `.text` 섹션의 가상 메모리 주소 위치를 구할 수 있음
    - 추가적으로, 코드 영역의 시작 위치인 `.init` 섹션의 오프셋 값이 `0x1000`이었던 것을 대입해본다면 두 번째 줄이 코드 영역(.init + .text + .plt + …..)의 가상 메모리 주소임을 확인할 수 있음
    
    ```bash
    556021d31000-556021d32000 r--p 00000000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    556021d32000-556021d33000 r-xp 00001000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    556021d33000-556021d34000 r--p 00002000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    556021d34000-556021d35000 r--p 00002000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    556021d35000-556021d36000 rw-p 00003000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    556022ecb000-556022eec000 rw-p 00000000 00:00 0                          [heap]
    7f4e4cc00000-7f4e4cc28000 r--p 00000000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4cc28000-7f4e4cdbd000 r-xp 00028000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    7f4e4cdbd000-7f4e4ce15000 r--p 001bd000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    
    ......
    ```
    

- **해당 예제의 결론**
    - **해당 예제를 통해 얻을 수 있는 결론은** `/proc/<pid>/maps` 파일의 두 번째 줄을 읽게 되면 코드 영역의 시작 주소와 끝 주소를 얻을 수 있다는 점이다.

### 4-3. `/proc/<pid>/maps` 파일을 읽어 코드 영역의 시작과 끝 메모리 주소 획득하기

아래 예제 코드는 인자로 주어진 pid의 maps 파일을 읽어오는 것으로, 코드 영역의 시작과 끝 메모리 주소를 출력한다.

- **예제 코드**
    
    ```c
    /* filename : read_proc_maps.c */
    
    #define _GNU_SOURCE
    #include <stdio.h>
    #include <fcntl.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <stdint.h>
    #include <string.h>
    
    #include <inttypes.h>
    
    typedef struct proc_map {
    	uint64_t start_addr;
    	uint64_t end_addr;
    	char 	 exec_mode[4];
    } proc_map, *pproc_map;
    
    int read_line_proc_maps(int fd, char* buff, ssize_t buff_sz) {
    	if (fd == -1 || buff == NULL || buff_sz <= 0) {
    		return -1;
    	}
    
    	ssize_t read_sz = 0;
    	char ch;
    	int idx = 0;
    	while( 0 < ( read_sz = read(fd, &ch, 1) ) ) {
    		if (buff_sz <= idx || ch == '\n') {
    			buff[idx] = '\0';
    			break;
    		}
    
    		buff[idx++] = ch;
    	}
    
    	return 0;
    }
    
    int get_proc_maps_info_by_line(int fd, pproc_map proc_map_buff) {
    	const ssize_t alloc_size = 150;
    	char* buff = NULL;
    
    	buff = (char *)calloc(alloc_size, sizeof(char));
            if (buff == NULL) {
           	        printf("memory allocate failed\n");
                   	return -1;
            }
    
    	if (-1 == read_line_proc_maps(fd, buff, alloc_size)) {
    		printf("read_line_proc_maps failed\n");
    		return -1;
    	}
    
    	sscanf(buff, "%lx-%lx %s", &(proc_map_buff->start_addr), &(proc_map_buff->end_addr), proc_map_buff->exec_mode);
    
    	return 0;
    }
    
    int main(int argc, char* argv[]) {
    	int fd = -1;
    
    	if (argc < 2) {
    		printf("run as : %s [target pid]\n", argv[0]);
    		return -1;
    	}
    
    	char* target_proc_path = NULL;
    	asprintf(&target_proc_path, "/proc/%s/maps", argv[1]);
    
    	if (target_proc_path == NULL) {
    		return -1;
    	}
    
    	if ( -1 == (fd = open(target_proc_path, O_RDONLY)) ) {
    		printf("file open failed\n");
    		return -1;
    	}
    
    	pproc_map proc_map_buff = (pproc_map)malloc(sizeof(proc_map));
    	for (int i = 0; i < 2; i++) {
    		get_proc_maps_info_by_line(fd, proc_map_buff);
    
    		if(strcmp(proc_map_buff->exec_mode, "r-xp") == 0) {
    			printf("start addr : %lx, end addr : %lx\n", proc_map_buff->start_addr, proc_map_buff->end_addr);
    		}
    	}
    
    	if(proc_map_buff != NULL)
    		free(proc_map_buff);
    
    	if(fd != -1)
    		close(fd);
    }
    ```
    

- **실행 결과**
    
    ```bash
    $ ./test2 5770
    start addr : 55ea7e639000, end addr : 55ea7e63a000
    
    $ cat /proc/5770/maps
    55ea7e638000-55ea7e639000 r--p 00000000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    **55ea7e639000-55ea7e63a000 r-xp** 00001000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    55ea7e63a000-55ea7e63b000 r--p 00002000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    55ea7e63b000-55ea7e63c000 r--p 00002000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    55ea7e63c000-55ea7e63d000 rw-p 00003000 08:03 2102898                    /home/gichoel/workdir/capstone_test/test
    55ea7ff55000-55ea7ff76000 rw-p 00000000 00:00 0                          [heap]
    7fa2dc800000-7fa2dc828000 r--p 00000000 08:03 1062035                    /usr/lib/x86_64-linux-gnu/libc.so.6
    
    ......
    
    ```
    

### 4-4. Capstone Disassembler 라이브러리 예제

아래 예제 코드는 main() 함수를 100byte만큼 잘라서 디스어셈블 결과를 출력하는 예제이기 때문에 다른 용도로 사용하기에는 문제가 있으며 Capstome Disassembler를 단순히 어떻게 사용하는지 테스트하기 위해서 작성된 예제이다.

- **예제 코드**
    
    ```c
    #include <stdio.h>
    #include <inttypes.h>
    
    #include <capstone/capstone.h>
    
    void callme() {
    	printf("callme() called\n");
    }
    
    int main(void)
    {
    	csh handle;
    	cs_insn* insn;
    	size_t count;
    
    	callme();
    
    	if(cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK)
    		return -1;
    
    	count = cs_disasm(handle, (uint8_t *)main, 100, 0x1223, 0, &insn);
    	if(count > 0) {
    		for(size_t j = 0; j < count; j++) {
    			printf("0x%"PRIx64":\t%s\t\t%s\n", insn[j].address, insn[j].mnemonic, insn[j].op_str);
    		}
    
    		cs_free(insn, count);
    	}
    	else
    		printf("ERROR: failed to disassemble given code!\n");
    
    	cs_close(&handle);
    
    	return 0;
    }
    
    ```
    

- 실행 결과
    
    ```nasm
    **$ ./capstone_test
    
    callme() called
    0x1223:	endbr64		
    0x1227:	push		rbp
    0x1228:	mov		rbp, rsp
    0x122b:	sub		rsp, 0x30
    0x122f:	mov		rax, qword ptr fs:[0x28]
    0x1238:	mov		qword ptr [rbp - 8], rax
    0x123c:	xor		eax, eax
    0x123e:	mov		eax, 0
    0x1243:	call		0x1209
    0x1248:	lea		rax, [rbp - 0x28]
    0x124c:	mov		rdx, rax
    0x124f:	mov		esi, 8
    0x1254:	mov		edi, 3
    0x1259:	call		0x1100
    0x125e:	test		eax, eax
    0x1260:	je		0x126c
    0x1262:	mov		eax, 0xffffffff
    0x1267:	jmp		0x1361
    0x126c:	mov		rax, qword ptr [rbp - 0x28]
    0x1270:	lea		rdx, [rbp - 0x20]
    0x1274:	mov		r9, rdx
    0x1277:	mov		r8d, 0
    0x127d:	mov		ecx, 0x1223
    0x1282:	mov		edx, 0x64**
    
    ```
    

### 4-5. `/proc/<pid>/maps` 파일을 읽어 Capstone Disassembler로 디스어셈블 해보기

- 전체 예제 코드
    
    ```c
    #define _GNU_SOURCE
    #include <stdio.h>
    #include <fcntl.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <stdint.h>
    #include <string.h>
    #include <inttypes.h>
    
    #include <capstone/capstone.h>
    
    typedef struct disasm_engine {
            csh handle;
    } disasm_engine;
    
    int disasm_engine_init(disasm_engine* disasm_eng_ptr)
    {
            if (disasm_eng_ptr == NULL) {
                    return -1;
            }
    
            if (cs_open(CS_ARCH_X86, CS_MODE_64, &disasm_eng_ptr->handle) != CS_ERR_OK) {
                    disasm_eng_ptr->handle = 0;
                    return -1;
            }
    
            return 0;
    }
    
    int disasm_engine_run(disasm_engine* disasm_eng_ptr, uint64_t start_addr, ssize_t len, size_t offset)
    {
            if (disasm_eng_ptr == NULL) {
                    return -1;
            }
    
            cs_insn* insn = NULL;
    
            size_t count = cs_disasm(disasm_eng_ptr->handle, (uint8_t *)start_addr, len, 0x0, 0, &insn);
            if (count <= 0) {
                    printf("Failed to disassemble given code\n");
                    return -1;
            }
    
            for(size_t j = 0; j < count; j++) {
                    printf("0x%"PRIx64":\t%s\t\t%s\n", insn[j].address, insn[j].mnemonic, insn[j].op_str);
            }
    
            return 0;
    }
    
    void disasm_engine_destroy(disasm_engine* disasm_eng_ptr)
    {
            if (disasm_eng_ptr == NULL) {
                    return;
            }
    
            if (disasm_eng_ptr->handle != 0) {
                    cs_close(&disasm_eng_ptr->handle);
            }
    }
    
    typedef struct proc_map {
            uint64_t start_addr;
            uint64_t end_addr;
            char     exec_mode[4];
            size_t   offset;
    } proc_map;
    
    int read_line_proc_maps(int fd, char* buff, ssize_t buff_sz)
    {
            if (fd == -1 || buff == NULL || buff_sz <= 0) {
                    return -1;
            }
    
            ssize_t read_sz = 0;
            char ch;
            int idx = 0;
            while( 0 < ( read_sz = read(fd, &ch, 1) ) ) {
                    if (buff_sz <= idx || ch == '\n') {
                            buff[idx] = '\0';
                            break;
                    }
    
                    buff[idx++] = ch;
            }
    
            return 0;
    }
    
    int get_proc_maps_info_by_line(int fd, proc_map* proc_map_buff)
    {
            static char buff[150] = {0};
    
            if (proc_map_buff == NULL) {
                    return -1;
            }
    
            memset(buff, 0, 150);
    
            if (-1 == read_line_proc_maps(fd, buff, 150)) {
                    printf("read_line_proc_maps failed\n");
                    return -1;
            }
    
            sscanf(buff, "%lx-%lx %s %lud", &(proc_map_buff->start_addr), &(proc_map_buff->end_addr), proc_map_buff->exec_mode, &proc_map_buff->offset);
    
            return 0;
    }
    
    int get_proc_maps_path(char* pid_str, char** proc_maps_path)
    {
            asprintf(proc_maps_path, "/proc/self/maps");
            if (proc_maps_path == NULL) {
                    printf("get_proc_maps_path failed\n");
                    return -1;
            }
    
            return 0;
    }
    
    int main(int argc, char* argv[])
    {
            char* target_proc_path = NULL;
            if ( -1 == get_proc_maps_path(argv[1], &target_proc_path) ) {
                    return -1;
            }
    
            int fd = -1;
            if ( -1 == (fd = open(target_proc_path, O_RDONLY)) ) {
                    printf("file open failed\n");
                    return -1;
            }
    
            proc_map* code_sect_info = NULL;
            if ( NULL == ( code_sect_info = (proc_map *)calloc(1, sizeof(proc_map)) ) ) {
                    return -1;
            }
    
            while(1) {
                    get_proc_maps_info_by_line(fd, code_sect_info);
                    if(strcmp(code_sect_info->exec_mode, "r-xp") == 0) {
                            break;
                    }
            }
    
            if (target_proc_path != NULL) {
                    free(target_proc_path);
            }
    
            if (fd != -1) {
                    close(fd);
            }
    
            disasm_engine* disasm_eng = (disasm_engine *)calloc(1, sizeof(disasm_engine));
            if (disasm_eng == NULL) {
                    return -1;
            }
    
            if (disasm_engine_init(disasm_eng) == -1) {
                    return -1;
            }
    
            if (disasm_engine_run(disasm_eng, code_sect_info->start_addr, (code_sect_info->end_addr - code_sect_info->start_addr), code_sect_info->offset)) {
                    return -1;
            }
    
            disasm_engine_destroy(disasm_eng);
    
            if (code_sect_info != NULL) {
                    free(code_sect_info);
            }
            
            return 0;
    }
    
    ```
    
    - `/proc/<pid>/maps`를 사용해 다른 프로세스의 maps 정보를 가져오더라도, 파싱한 주소 값은 결국 해당 프로세스에서만 접근 가능한 메모리 주소 영역이기 때문에  위 예제 코드는 자기 자신만 접근이 가능하다.
    - 따라서, 디스어셈블 결과가 조금 복잡하긴 하고 `objdump-d` 명령이랑 비교했을 때 바이트 코드를 디스어셈블로 변환하는 과정에서 동일한 동작이어도 `objdump -d`와 `capstone` 라이브러리가 서로 다른 명령어로 변환하는 경우가 있어 이 부분을 감안하면 동일한 것을 확인할 수 있다.
    - 위 예제를 `uftrace` 처럼 타겟 프로그램의 디스어셈블 정보를 구하기 위해서는 동적 라이브러리로 생성 후 타겟 프로그램에 삽입해야 한다.
    
- **해당 예제의 문제점**
    - objdump -d와 readelf -SW는 ELF 파일에 있는 섹션들을 파싱하기 때문에 섹션들의 시작 위치와 끝 위치를 알 수 있어 정확히 출력하는 것으로 보이지만, 위 예제는 메모리에 올라간 프로그램의 영역을 파싱하는 것이고 메모리에 존재하는 실행파일은 Page Size에 맞게 정렬 되어 있어 패딩이 존재하기 때문에 end addr이 패딩을 포함한 영역을 가리키다 보니 끝 부분은 일치하지 않을 수 있다.

- **예제 작성 시 참조한 URL**
    - Ref URL 1 : [https://umbum.tistory.com/140](https://umbum.tistory.com/140)
    - Ref URL 2 : [https://www.capstone-engine.org/lang_c.html](https://www.capstone-engine.org/lang_c.html)
    - Ref URL 3 : [https://www.hahwul.com/2015/09/08/system-hacking-procselfmaps/](https://www.hahwul.com/2015/09/08/system-hacking-procselfmaps/)
    - Ref URL 4 : [https://stackoverflow.com/a/1401595](https://stackoverflow.com/a/1401595)
    - Ref URL 5 : [https://stackoverflow.com/a/76756997](https://stackoverflow.com/a/76756997)
    - Ref URL 6 : [https://github.com/khalladay/hooking-by-example/blob/master/hooking-by-example/10 - Trampoline With Disassembler In Same Process/trampoline-with-disasm.cpp](https://github.com/khalladay/hooking-by-example/blob/master/hooking-by-example/10%20-%20Trampoline%20With%20Disassembler%20In%20Same%20Process/trampoline-with-disasm.cpp)
    - Ref URL 7 : [https://meetup.nhncloud.com/posts/378](https://meetup.nhncloud.com/posts/378)
    - Ref URL 8 : [https://github.com/kubo/funchook/blob/master/src/os_unix.c](https://github.com/kubo/funchook/blob/master/src/os_unix.c)
